---

title: "Bootstrapped TLS Authentication"
abbrev: TLS-POK
docname: draft-friel-tls-eap-dpp-00
category: std

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: O. Friel
    name: Owen Friel
    org: Cisco
    email: ofriel@cisco.com
 -
    ins: D. Harkins
    name: Dan Harkins
    org: Hewlett-Packard Enterprise
    email: daniel.harkins@hpe.com
informative:
  DPP:
    author:
      org: Wi-Fi Alliance
    title: Device Provisioning Profile
    date: 2019
  Stajano:
    author:
      name: Stajano, F. and R. Anderson
    title: "The Ressurecting Ducking: Security Issues for Ad-Hoc Wireless Networks"
    date: 1999

--- abstract

This document defines a TLS extension that enables a server to prove to a client that it has knowledge of the public key of a key pair where the client has knowledge of the private key of the key pair. Unlike standard TLS key exchanges, the public key pair is never exchanged in TLS protocol messages. Proof of knowledge of the public key is used by the client to bootstrap trust in the server, and the primary use case is to establish trust in an EAP server.

--- middle


# Introduction

On-boarding of devices with no, or limited, user interface can be difficult.  Typically, a credential is needed to access the network
and network connectivity is needed to obtain a credential.  This poses a catch-22.

If trust in the integrity of a device's public key can be obtained in an out-of-band fashion, a device can be authenticated and provisioned with a usable credential for network access.  While this authentication can be strong, the device's authentication of the network is somewhat weaker.  [Stajano]] presents a functional security model to address this asymmetry.

There are on-boarding protocols, such as [DPP], to address this use case but these do not address large-scale, enterprise deployments that require an X.509 certificate for network access.  This document describes such a protocol.

## Bootstrap Key Pair

The mechanism for on-boarding of devices defined in this document relies on bootstrap key pairs. A client device has an associated elliptic curve (EC) key pair. The key pair may be static and baked into device firmware at manufacturing time, or may be dynamic and generated at on-boarding time by the device.

The public key of the device is known to the TLS server. More specifically, the ASN.1 SEQUENCE SubjectPublicKeyInfo from {{?RFC5280}} is known to the server, which means that the associated AlgorithmIdentifier and EC curve is known to the server.

The exact mechanism by which the server gains knowledge of the public key is out of scope of this specification, but possible mechanisms include scanning of a QR code or upload of a Bill of Materials (BOM).

Using the extensions defined herein, the server proves to the client that it has knowledge of the client's bootstrap public key. Similarly, the client proves to the server that it has knowledge of the associated private key. This gives a guarantee to the client that it is connecting to a server that knows its bootstrap public key. Similarly, this gives a guarantee to the server that the connecting client owns the key pair.

# Using Bootstrapping in TLS 1.3

The bootstrapping modifications introduce a extension to identify a "bootstrapping" key into the TLS 1.3 handshake.  This key MUST be from a cryptosystem suitable for doing (EC)DH.  When using the bootstrapping extension, two (EC)DH operations are performed, a static-ephemeral (using the client's bootstrapping key and an ephemeral key generated by the server) and an ephemeral-ephemeral (using the client's ephemeral key and an ephemeral key generated by the server).

## Server Ephemeral Key Options

[[ TODO:  Need to decide which mechanism to use here ]]

There are two options for generation of the server's ephemeral key.

- server generates one ephemeral key pair: the key pair is reused by the server for both static-ephemeral (bootstrap) and ephemeral-ephemeral (TLS key_share) ECDH exchanges. This means that the bootstrap and key_share keys MUST be on the same curve.

- server generates two ephemeral key pairs: one that is used for the static-ephemeral (bootstrap) ECDH exchange, and one that is used for the ephemeral-ephemeral (TLS key_share) DH exchange. The bootstrap and key_share keys are independent. The key_share keys may be Finite Field DH keys.

This document assumes the latter and that the server generates unique ephemeral key pairs for bootstrap and key_share.

## Bootstrapping Key Naming

The bootstrapping key of the client is specified using the bskey extension.  The "extension data" field of this extension SHALL consist of the base64 encoded SHA256 digest of the DER-encoded ASN.1 subjectPublicKeyInfo representation of the bootstrapping public key. The extension is:

      opaque bskey[32];

The bskey is a 32 byte string.  The ExtensionType of bskey is TBD.

## Bootstrap Key Extension

      struct {
          opaque bskey[32];
      } BootstrapKey;

The bootstrapping key of the client is specified using the BootstrapKey extension.  The 'bskey' field of this extension SHALL consist of the base64 encoded SHA256 digest of the DER-encoded ASN.1 subjectPublicKeyInfo representation of the bootstrapping public key.

##  Changes to TLS 1.3 Handshake

The client identifies the bootstrapping key in the ClientHello using the BootstrapKey extension. The server looks up the client's bootstrapping key in its database by checking the SHA256 hash of each entry with the value received in the ClientHello.  If no match is found, the server SHOULD respond with an unknown_bskey error alert.

If the server found the matching bootstrap key, the server generates an ephemeral ECDH keypair on the curve indicated in the bootstrap public key information, and performs an ECDH operation using the client bootstrap key and the server's ephemeral keypair. The server echos the BootstrapKey extension back to the client in the ServerHello to explicitly confirm to the client that it has performed an ECDH using the bootstrap key, and has injected the output into the key schedule.

This is in addition to, and independent from, the (EC)DH that the server carries out when handling the key_share extension.

The handshake is shown in Figure 1.

~~~

         Client                                            Server
         --------                                          --------
         ClientHello
         + bskey
         + key_share                -------->
                                                        ServerHello
                                                        + bskey
                                                        + key_share
                                              {EncryptedExtensions}
                                                         {Finished}
                                    <--------   [Application Data*]
         {Finished}                 -------->
         [Application Data]         <------->    [Application Data]
~~~


                    Figure 1: TLS 1.3 TLS-PWD Handshake

## Changes to TLS 1.3 Key Schedule

[[ TODO: need to fixup this, what if the key_share is finite field? ]]

The x-coordinate of the two ECDH shared secret points are concatenated, bootstrapping key first, ephemeral key second, to create a concatenated shared secret for the TLS 1.3 key schedule. 

The key schedule for bootstrapping TLS is as follows.

~~~
                                       0
                                       |
                                       v
                         PSK ->  HKDF-Extract = Early Secret
                                       |
                                       +-----> Derive-Secret(...)
                                       +-----> Derive-Secret(...)
                                       +-----> Derive-Secret(...)
                                       |
                                       v
                                 Derive-Secret(., "derived", "")
                                       |
                                       v
   concatenated_shared_secret -> HKDF-Extract = Handshake Secret
                                       |
                                       +-----> Derive-Secret(...)
                                       +-----> Derive-Secret(...)
                                       |
                                       v
                                 Derive-Secret(., "derived", "")
                                       |
                                       v
                            0 -> HKDF-Extract = Master Secret
                                       |
                                       +-----> Derive-Secret(...)
                                       +-----> Derive-Secret(...)
                                       +-----> Derive-Secret(...)
                                       +-----> Derive-Secret(...)
~~~


# Using TLS Bootstrapping in EAP

Enterprise deployments typically require an 802.1x/EAP-based authentication to obtain network access.  Devices whose boostrapping key has been obtained in an out-of-band fashion can perform an EAP-TLS-based exchange, for instance {{?RFC7170}}, and authenticate the TLS exchange using the bootstrapping extensions defined in Section 2.

# IANA Considerations

IANA will allocated an ExtensionType for the bskey extension from the appropriate TLS 1.3 repository and replace TBD in this document with that number.

# Security Considerations 

[[TODO]]


